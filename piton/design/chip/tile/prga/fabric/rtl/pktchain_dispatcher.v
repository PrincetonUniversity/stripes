// Copyright (c) 2024 Princeton University
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the copyright holder nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Automatically generated by PRGA's RTL generator
`include "pktchain.vh"
`timescale 1ns/1ps
module pktchain_dispatcher (
    input wire [0:0] prog_clk,
    input wire [0:0] prog_rst,

    // noc inputs
    output wire [0:0] phit_i_full,
    input wire [0:0] phit_i_wr,
    input wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0] phit_i,

    // noc outputs
    input wire [0:0] phit_ox_full,
    output wire [0:0] phit_ox_wr,
    output wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0] phit_ox,

    input wire [0:0] phit_oy_full,
    output wire [0:0] phit_oy_wr,
    output wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0] phit_oy
    );

    // register reset signal
    reg prog_rst_f;

    always @(posedge prog_clk) begin
        prog_rst_f <= prog_rst;
    end

    wire frame_i_empty, frame_ox_full, frame_oy_full;
    wire [`PRGA_PKTCHAIN_FRAME_SIZE - 1:0] frame_i;
    reg [`PRGA_PKTCHAIN_FRAME_SIZE - 1:0] frame_ox;
    reg frame_i_rd, frame_ox_wr, frame_oy_wr;

    pktchain_frame_assemble ififo (
        .prog_clk       (prog_clk)
        ,.prog_rst      (prog_rst_f)
        ,.phit_full     (phit_i_full)
        ,.phit_wr       (phit_i_wr)
        ,.phit_i        (phit_i)
        ,.frame_empty   (frame_i_empty)
        ,.frame_rd      (frame_i_rd)
        ,.frame_o       (frame_i)
        );

    pktchain_frame_disassemble ox (
        .prog_clk       (prog_clk)
        ,.prog_rst      (prog_rst_f)
        ,.frame_full    (frame_ox_full)
        ,.frame_wr      (frame_ox_wr)
        ,.frame_i       (frame_ox)
        ,.phit_full     (phit_ox_full)
        ,.phit_wr       (phit_ox_wr)
        ,.phit_o        (phit_ox)
        );

    pktchain_frame_disassemble oy (
        .prog_clk       (prog_clk)
        ,.prog_rst      (prog_rst_f)
        ,.frame_full    (frame_oy_full)
        ,.frame_wr      (frame_oy_wr)
        ,.frame_i       (frame_i)
        ,.phit_full     (phit_oy_full)
        ,.phit_wr       (phit_oy_wr)
        ,.phit_o        (phit_oy)
        );

    localparam  STATE_RESET                         = 4'h0,
                STATE_IDLE                          = 4'h1,
                STATE_FORWARD_X                     = 4'h2,
                STATE_FORWARD_Y                     = 4'h3;

    reg [3:0] state, state_next;
    reg [`PRGA_PKTCHAIN_PAYLOAD_WIDTH - 1:0] payload;
    reg payload_rst;

    always @(posedge prog_clk) begin
        if (prog_rst_f) begin
            state <= STATE_RESET;
            payload <= 'b0;
        end else begin
            state <= state_next;

            if (payload_rst) begin
                payload <= frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX];
            end else if (!frame_i_empty && frame_i_rd) begin
                payload <= payload - 1;
            end
        end
    end

    always @* begin
        frame_i_rd = 'b0;
        frame_ox = frame_i;
        frame_ox_wr = 'b0;
        frame_oy_wr = 'b0;
        state_next = state;
        payload_rst = 'b0;

        case (state)
            STATE_RESET: begin
                state_next = STATE_IDLE;
            end
            STATE_IDLE: begin
                if (!frame_i_empty) begin
                    if (frame_i[`PRGA_PKTCHAIN_BRANCH_ID_INDEX] == 0) begin
                        frame_oy_wr = 'b1;
                        payload_rst = 'b1;

                        if (!frame_oy_full) begin
                            frame_i_rd = 'b1;

                            if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                                state_next = STATE_FORWARD_Y;
                            end
                        end
                    end else begin
                        frame_ox = frame_i - (1 << `PRGA_PKTCHAIN_BRANCH_ID_BASE);
                        frame_ox_wr = 'b1;
                        payload_rst = 'b1;

                        if (!frame_ox_full) begin
                            frame_i_rd = 'b1;

                            if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                                state_next = STATE_FORWARD_X;
                            end
                        end
                    end
                end
            end
            STATE_FORWARD_X: begin
                frame_i_rd = !frame_ox_full;
                frame_ox_wr = !frame_i_empty;

                if (payload == 1 && !frame_i_empty && !frame_ox_full) begin
                    state_next = STATE_IDLE;
                end
            end
            STATE_FORWARD_Y: begin
                frame_i_rd = !frame_oy_full;
                frame_oy_wr = !frame_i_empty;

                if (payload == 1 && !frame_i_empty && !frame_oy_full) begin
                    state_next = STATE_IDLE;
                end
            end
        endcase
    end

endmodule