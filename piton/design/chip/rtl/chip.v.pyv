// Copyright (c) 2024 Princeton University
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the copyright holder nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

`ifndef USE_TEST_TOP // useless for older TOPs

`include "define.tmp.h"
`include "piton_system.vh"
`include "jtag.vh"

`ifdef PITON_PRGA
    `include "prga_axi4.vh"
`endif
module chip(
`ifndef PITON_CHIP_FPGA
   // IO cell configs
   input                                        slew,
   input                                        impsel1,
   input                                        impsel2,
`endif // endif PITON_CHIP_FPGA

`ifdef PITON_FPGA_CLKS_GEN
   input                                        clk_osc_p,
   input                                        clk_osc_n,
`else // ifndef PITON_FPGA_CLKS_GEN
   // Input clocks
   input                                        core_ref_clk,
   input                                        io_clk,
`endif // endif PITON_FPGA_CLKS_GEN

   // Resets
   // reset is assumed to be asynchronous
   input                                        rst_n,
`ifndef PITON_CHIP_FPGA
   input                                        pll_rst_n,

   // Chip-level clock enable
   input                                        clk_en,

   // PLL settings
   output                                       pll_lock,
   input                                        pll_bypass,
   input  [4:0]                                 pll_rangea,

   // Clock mux select (bypass PLL or not)
   // Double redundancy with pll_bypass
   input  [1:0]                                 clk_mux_sel,

   // JTAG
   input                                        jtag_clk,
   input                                        jtag_rst_l,
   input                                        jtag_modesel,
   input                                        jtag_datain,
   output                                       jtag_dataout,

   // Async FIFOs enable
   input                                        async_mux,

   // ORAM
   input                                        oram_on,
   input                                        oram_traffic_gen,
   input                                        oram_dummy_gen,
`else // ifdef PITON_CHIP_FPGA
   // Need to output this to chipset, since there will
   // be no passthru in the case of synthesizing chip on its own
   output                                       piton_prsnt_n,
   output                                       piton_ready_n,

   input                                        chipset_prsnt_n,

   output [7:0]                                 leds,
`endif // endif PITON_CHIP_FPGA

`ifndef PITON_NO_CHIP_BRIDGE
   // For FPGA implementations, we convert to differential and source synchronous
`ifdef PITON_CHIP_FPGA
   output                                      chip_intf_clk_p,
   output                                      chip_intf_clk_n,
   input                                       intf_chip_clk_p,
   input                                       intf_chip_clk_n,

   output [31:0]                               chip_intf_data_p,
   output [31:0]                               chip_intf_data_n,
   output [1:0]                                chip_intf_channel_p,
   output [1:0]                                chip_intf_channel_n,
   input  [2:0]                                chip_intf_credit_back_p,
   input  [2:0]                                chip_intf_credit_back_n,

   input  [31:0]                               intf_chip_data_p,
   input  [31:0]                               intf_chip_data_n,
   input  [1:0]                                intf_chip_channel_p,
   input  [1:0]                                intf_chip_channel_n,
   output [2:0]                                intf_chip_credit_back_p,
   output [2:0]                                intf_chip_credit_back_n
`else // ifndef PITON_CHIP_FPGA
   // Virtual channel credit-based off-chip interface
   input  [31:0]                                intf_chip_data,
   input  [1:0]                                 intf_chip_channel,
   output [2:0]                                 intf_chip_credit_back,

   output [31:0]                                chip_intf_data,
   output [1:0]                                 chip_intf_channel,
   input  [2:0]                                 chip_intf_credit_back
`endif // endif PITON_CHIP_FPGA
`else // ifdef PITON_NO_CHIP_BRIDGE
   output                                       processor_offchip_noc1_valid,
   output [`NOC_DATA_WIDTH-1:0]                 processor_offchip_noc1_data,
   input                                        processor_offchip_noc1_yummy,
   output                                       processor_offchip_noc2_valid,
   output [`NOC_DATA_WIDTH-1:0]                 processor_offchip_noc2_data,
   input                                        processor_offchip_noc2_yummy,
   output                                       processor_offchip_noc3_valid,
   output [`NOC_DATA_WIDTH-1:0]                 processor_offchip_noc3_data,
   input                                        processor_offchip_noc3_yummy,

   input                                        offchip_processor_noc1_valid,
   input  [`NOC_DATA_WIDTH-1:0]                 offchip_processor_noc1_data,
   output                                       offchip_processor_noc1_yummy,
   input                                        offchip_processor_noc2_valid,
   input  [`NOC_DATA_WIDTH-1:0]                 offchip_processor_noc2_data,
   output                                       offchip_processor_noc2_yummy,
   input                                        offchip_processor_noc3_valid,
   input  [`NOC_DATA_WIDTH-1:0]                 offchip_processor_noc3_data,
   output                                       offchip_processor_noc3_yummy
`endif // endif PITON_NO_CHIP_BRIDGE

`ifndef PITON_RVIC

`ifdef PITON_RV64_PLATFORM
`ifdef PITON_RV64_DEBUGUNIT
    // Debug
,   input                                       ndmreset_i      // non-debug module reset
,   input   [`PITON_RV64_TILES-1:0]              debug_req_i     // async debug request
,   output  [`PITON_RV64_TILES-1:0]              unavailable_o   // communicate whether the hart is unavailable (e.g.: power down)
`endif // ifdef PITON_RV64_DEBUGUNIT

`ifdef PITON_RV64_CLINT
    // CLINT
,   input   [`PITON_RV64_TILES-1:0]              timer_irq_i     // Timer interrupts
,   input   [`PITON_RV64_TILES-1:0]              ipi_i           // software interrupt (a.k.a inter-process-interrupt)
`endif // ifdef PITON_RV64_CLINT

`ifdef PITON_RV64_PLIC
    // PLIC
,   input   [`PITON_RV64_TILES*2-1:0]            irq_i           // level sensitive IR lines, mip & sip (async)
`endif // ifdef PITON_RV64_PLIC
`endif // ifdef PITON_RV64_PLATFORM

`endif // ifndef PITON_RVIC
);

`ifdef PITON_ARIANE
`ifdef PITON_RVIC
    wire  [`PITON_RV64_TILES * 2 - 1:0]   irq;        // change the ariane PLIC input to a wire which outputs from PRGA
    wire  [`PITON_RV64_TILES - 1 : 0]     timer_irq;
    wire  [`PITON_RV64_TILES - 1:0]       ipi;
`endif
`endif

<%
    import os
    import sys
    from pyhplib import *

    # Add pyocn/py to python path
    if PITON_NETWORK_CONFIG == "pyocn_config" or PITON_NETWORK_CONFIG == "pyocn_router_config":
        DV_ROOT = os.getenv( 'DV_ROOT' )
        assert DV_ROOT is not None, "Environment variable DV_ROOT is not defined!"
        sys.path.insert( 0, os.path.join( DV_ROOT, 'design/chip/pyocn/py' ) )
        import pyocn_chip_utils
%>

   ///////////////////////
   // Type Declarations
   ///////////////////////

   // Need to define types for missing inputs and outputs
   // if synthesizing chip to fpga standalone
`ifdef PITON_CHIP_FPGA
   wire                                         slew;
   wire                                         impsel1;
   wire                                         impsel2;


   wire                                         pll_rst_n;

   wire                                         clk_en;

   wire                                         pll_lock;
   wire                                         pll_bypass;
   wire [4:0]                                   pll_rangea;

   wire [1:0]                                   clk_mux_sel;

   wire                                         jtag_clk;
   wire                                         jtag_rst_l;
   wire                                         jtag_modesel;
   wire                                         jtag_datain;
   wire                                         jtag_dataout;

   wire                                         async_mux;

   wire                                         oram_on;
   wire                                         oram_traffic_gen;
   wire                                         oram_dummy_gen;
`endif // endif PITON_CHIP_FPGA
   // Same for generating clocks
`ifdef PITON_FPGA_CLKS_GEN
   wire                                         core_ref_clk;

   wire                                         mmcm_locked;
`endif // endif PITON_FPGA_CLKS_GEN
   // Same for chip interface
`ifndef PITON_NO_CHIP_BRIDGE
`ifdef PITON_CHIP_FPGA
   wire                                         io_clk;

   wire [31:0]                                  intf_chip_data;
   wire [1:0]                                   intf_chip_channel;
   wire [2:0]                                   intf_chip_credit_back;

   wire [31:0]                                  chip_intf_data;
   wire [1:0]                                   chip_intf_channel;
   wire [2:0]                                   chip_intf_credit_back;
`endif // endif PITON_CHIP_FPGA
`endif // endif PITON_NO_CHIP_BRIDGE

   // OCI internal wires

   wire                                         core_ref_clk_inter;
   wire                                         io_clk_inter;
   wire                                         rst_n_inter;
   wire                                         pll_rst_n_inter;
   wire                                         clk_en_inter;
   wire                                         pll_lock_inter;
   wire                                         pll_bypass_inter;
   wire [4:0]                                   pll_rangea_inter;
   wire [1:0]                                   clk_mux_sel_inter;
   wire                                         jtag_clk_inter;
   wire                                         jtag_rst_l_inter;
   wire                                         jtag_rst_l_inter_sync;
   wire                                         jtag_modesel_inter;
   wire                                         jtag_datain_inter;
   wire                                         jtag_dataout_inter;
   wire                                         async_mux_inter;
   wire                                         oram_on_inter;
   wire                                         oram_traffic_gen_inter;
   wire                                         oram_dummy_gen_inter;
   wire [31:0]                              intf_chip_data_inter;
   wire [1:0]                                   intf_chip_channel_inter;
   wire [2:0]                                   intf_chip_credit_back_inter;
   wire [31:0]                                  chip_intf_data_inter;
   wire [1:0]                                   chip_intf_channel_inter;
   wire [2:0]                                   chip_intf_credit_back_inter;

   // Synchronized resets
   wire                                         rst_n_inter_sync;
   reg                                          rst_n_inter_sync_f, rst_n_inter_sync_ff;
   wire                                         io_clk_rst_n_inter_sync;
   reg                                          io_clk_rst_n_inter_sync_f;

`ifndef PITON_PLL_BSG_CLK_GEN
   // PLL signals
   wire                                         core_ref_clk_inter_c;
   wire                                         core_ref_clk_inter_t;
   wire                                         clk_muxed;
   wire                                         pll_clk;
`else
   // Clock generator signals
   wire                                         clk_muxed;
`endif

   // Buffered chip bridge inputs
   reg  [31:0]                                  intf_chip_data_inter_buf_f /* synthesis iob = true */;
   reg  [1:0]                                   intf_chip_channel_inter_buf_f /* synthesis iob = true */;
   reg  [2:0]                                   chip_intf_credit_back_inter_buf_f /* synthesis iob = true */;

   // Chip bridge val/rdy interface
   wire                                         chip_intf_noc1_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   chip_intf_noc1_data;
   wire                                         chip_intf_noc1_rdy;
   wire                                         chip_intf_noc2_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   chip_intf_noc2_data;
   wire                                         chip_intf_noc2_rdy;
   wire                                         chip_intf_noc3_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   chip_intf_noc3_data;
   wire                                         chip_intf_noc3_rdy;

   wire                                         intf_chip_noc1_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   intf_chip_noc1_data;
   wire                                         intf_chip_noc1_rdy;
   wire                                         intf_chip_noc2_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   intf_chip_noc2_data;
   wire                                         intf_chip_noc2_rdy;
   wire                                         intf_chip_noc3_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   intf_chip_noc3_data;
   wire                                         intf_chip_noc3_rdy;

`ifndef PITON_NO_CHIP_BRIDGE
   // Need to convert a chip bridge interface to these if PITON_NO_CHIP_BRIDGE
   // is not specified
   wire                                         processor_offchip_noc1_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   processor_offchip_noc1_data;
   wire                                         processor_offchip_noc1_yummy;
   wire                                         processor_offchip_noc2_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   processor_offchip_noc2_data;
   wire                                         processor_offchip_noc2_yummy;
   wire                                         processor_offchip_noc3_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   processor_offchip_noc3_data;
   wire                                         processor_offchip_noc3_yummy;

   wire                                         offchip_processor_noc1_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   offchip_processor_noc1_data;
   wire                                         offchip_processor_noc1_yummy;
   wire                                         offchip_processor_noc2_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   offchip_processor_noc2_data;
   wire                                         offchip_processor_noc2_yummy;
   wire                                         offchip_processor_noc3_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   offchip_processor_noc3_data;
   wire                                         offchip_processor_noc3_yummy;
`endif // endif PITON_NO_CHIP_BRIDGE

   // ORAM muxed outputs
   reg                                          proc_oram_yummy;
   reg                                          oram_proc_valid;
   reg  [`NOC_DATA_WIDTH-1:0]                   oram_proc_data;
   reg                                          offchip_oram_yummy;
   reg                                          oram_offchip_valid;
   reg  [`NOC_DATA_WIDTH-1:0]                   oram_offchip_data;

   // ORAM Signals
   wire                                         proc_oram_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   proc_oram_data;
   wire                                         proc_oram_yummy_oram;
   wire                                         oram_proc_valid_oram;
   wire [`NOC_DATA_WIDTH-1:0]                   oram_proc_data_oram;
   wire                                         oram_proc_yummy;

   wire                                         offchip_oram_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   offchip_oram_data;
   wire                                         offchip_oram_yummy_oram;
   wire                                         oram_offchip_valid_oram;
   wire [`NOC_DATA_WIDTH-1:0]                   oram_offchip_data_oram;
   wire                                         oram_offchip_yummy;

   // ORAM JTAG Signals
   wire                                         ctap_oram_clk_en;
   wire                                         ctap_oram_req_val;
   wire [`JTAG_ORAM_MISC_WIDTH-1:0]             ctap_oram_req_misc;
   wire [`JTAG_ORAM_DATA_WIDTH-1:0]             oram_ctap_res_data;
   // wire [`BIST_OP_WIDTH-1:0]                    ctap_oram_bist_command;
   // wire [`SRAM_WRAPPER_BUS_WIDTH-1:0]           ctap_oram_bist_data;
   // wire [`SRAM_WRAPPER_BUS_WIDTH-1:0]           oram_ctap_sram_data;

   // Merged JTAG outputs from tile
   wire                                         tiles_jtag_ucb_val;
   wire [`UCB_BUS_WIDTH-1:0]                    tiles_jtag_ucb_data;

   // Tiles JTAG interface
   wire                                         jtag_tiles_ucb_val;
   wire [`UCB_BUS_WIDTH-1:0]                    jtag_tiles_ucb_data;
   wire [127:0]                                 ctap_clk_en_inter; // trin TODO: parameterize this number (63)
   <%
       # generate wires
       for i in range(PITON_X_TILES):
           for j in range(PITON_Y_TILES):
               flatid = i + (j * PITON_X_TILES)
               print("wire tile%d_jtag_ucb_val;" % flatid)
               print("wire [`UCB_BUS_WIDTH-1:0] tile%d_jtag_ucb_data;" % flatid)
   %>

   // Generate tile wiring
<%
   if (PITON_NETWORK_CONFIG == "xbar_config"):
       for i in range(PITON_X_TILES + 1):
           for k in [1,2,3]:
               print("wire [`DATA_WIDTH-1:0] xbar_%d_out_noc%d_data;" % (i, k))
               print("wire xbar_%d_out_noc%d_valid;" % (i, k))
               print("wire xbar_%d_out_noc%d_yummy;" % (i, k))
       for i in range(PITON_X_TILES):
           for j in range(PITON_Y_TILES):
               for k in [1,2,3]:
                   print("wire [`DATA_WIDTH-1:0] tile_%d_%d_out_noc%d_data;" % (j,i,k))
                   print("wire tile_%d_%d_out_noc%d_valid;" % (j,i,k))
                   print("wire tile_%d_%d_out_noc%d_yummy;" % (j,i,k))
       # make offchip signals
       for k in [1,2,3]:
           print("wire [`DATA_WIDTH-1:0] offchip_out_noc%d_data;" % (k))
           print("wire offchip_out_noc%d_valid;" % (k))
           print("wire offchip_out_noc%d_yummy;" % (k))

   elif PITON_NETWORK_CONFIG == "pyocn_config":
     pyocn_chip_utils.print_tile_noc_wires( PITON_X_TILES, PITON_Y_TILES )

   elif PITON_NETWORK_CONFIG == "pyocn_router_config":
     pyocn_chip_utils.print_router_tile_wiring( PITON_X_TILES, PITON_Y_TILES )

   else:
       for i in range(PITON_X_TILES):
           for j in range(PITON_Y_TILES):
               currentid = (i, j);
               rightid = (i, j + 1);
               downid = (i + 1, j);
               flatid = i + (j * PITON_X_TILES);
               for k in [1,2,3]:
                   # print "`ifdef RTL_SPARC%d" % flatid
                   print("wire [`DATA_WIDTH-1:0] tile_%d_%d_out_N_noc%d_data;" % (j,i,k))
                   print("wire [`DATA_WIDTH-1:0] tile_%d_%d_out_S_noc%d_data;" % (j,i,k))
                   print("wire [`DATA_WIDTH-1:0] tile_%d_%d_out_E_noc%d_data;" % (j,i,k))
                   print("wire [`DATA_WIDTH-1:0] tile_%d_%d_out_W_noc%d_data;" % (j,i,k))
                   print("wire tile_%d_%d_out_N_noc%d_valid;" % (j,i,k))
                   print("wire tile_%d_%d_out_S_noc%d_valid;" % (j,i,k))
                   print("wire tile_%d_%d_out_E_noc%d_valid;" % (j,i,k))
                   print("wire tile_%d_%d_out_W_noc%d_valid;" % (j,i,k))
                   print("wire tile_%d_%d_out_N_noc%d_yummy;" % (j,i,k))
                   print("wire tile_%d_%d_out_S_noc%d_yummy;" % (j,i,k))
                   print("wire tile_%d_%d_out_E_noc%d_yummy;" % (j,i,k))
                   print("wire tile_%d_%d_out_W_noc%d_yummy;" % (j,i,k))
                   # print "`else"
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_N_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_S_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_E_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_W_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_N_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_S_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_E_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_W_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_N_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_S_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_E_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_W_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "`endif"
       # make some dummy signals
       for k in [1,2,3]:
           print("wire [`DATA_WIDTH-1:0] dummy_out_N_noc%d_data = `DATA_WIDTH'b0;" % (k))
           print("wire [`DATA_WIDTH-1:0] dummy_out_S_noc%d_data = `DATA_WIDTH'b0;" % (k))
           print("wire [`DATA_WIDTH-1:0] dummy_out_E_noc%d_data = `DATA_WIDTH'b0;" % (k))
           print("wire [`DATA_WIDTH-1:0] dummy_out_W_noc%d_data = `DATA_WIDTH'b0;" % (k))
           print("wire dummy_out_N_noc%d_valid = 1'b0;" % (k))
           print("wire dummy_out_S_noc%d_valid = 1'b0;" % (k))
           print("wire dummy_out_E_noc%d_valid = 1'b0;" % (k))
           print("wire dummy_out_W_noc%d_valid = 1'b0;" % (k))
           print("wire dummy_out_N_noc%d_yummy = 1'b0;" % (k))
           print("wire dummy_out_S_noc%d_yummy = 1'b0;" % (k))
           print("wire dummy_out_E_noc%d_yummy = 1'b0;" % (k))
           print("wire dummy_out_W_noc%d_yummy = 1'b0;" % (k))
       # make offchip signals
       for k in [1,2,3]:
           print("wire [`DATA_WIDTH-1:0] offchip_out_S_noc%d_data;" % (k))
           print("wire offchip_out_S_noc%d_valid;" % (k))
           print("wire offchip_out_S_noc%d_yummy;" % (k))
%>

   //////////////////////
   // Sequential logic
   //////////////////////

   // trin 2/3/15:
   // rst in the tile is flopped for an additional cycle
   // we'll do the same for all other modules at the chip.v level
   //
   // angl 2/12/21:
   // for large chips, one cycle distribution from top to tiles might not be
   // enough. Therefore, we're adding two extra flops **PER TILE** between the
   // sync'ed reset and each tile.
   //
   // The ffs below are for everything except tiles, e.g. credit_to_valrdy and
   // valrdy_to_credit converters, chip_bridge, etc.
   always @ (posedge clk_muxed) begin
      rst_n_inter_sync_f <= rst_n_inter_sync;
      rst_n_inter_sync_ff <= rst_n_inter_sync_f;
  end

   always @ (posedge io_clk_inter)
      io_clk_rst_n_inter_sync_f <= io_clk_rst_n_inter_sync;

`ifndef PITON_NO_CHIP_BRIDGE
   // Buffer chip bridge inputs
   always @(posedge io_clk_inter)
   begin
`ifdef PITON_PROTO
       if(~io_clk_rst_n_inter_sync_f)
`else // ifndef PITON_PROTO
       if(~rst_n_inter_sync_ff)
`endif
       begin
           intf_chip_data_inter_buf_f <= 0;
           intf_chip_channel_inter_buf_f <= 0;
           chip_intf_credit_back_inter_buf_f <= 0;
       end
       else
       begin
           intf_chip_data_inter_buf_f <= intf_chip_data_inter;
           intf_chip_channel_inter_buf_f <= intf_chip_channel_inter;
           chip_intf_credit_back_inter_buf_f <= chip_intf_credit_back_inter;
       end
   end
`endif // endif PITON_NO_CHIP_BRIDGE

   ////////////////////////
   // Combinational Logic
   ////////////////////////

   // Need to assign missing inputs and outputs if synthesizing
   // chip for FPGA standalone
`ifdef PITON_CHIP_FPGA
   assign slew = 1'b1;
   assign impsel1 = 1'b1;
   assign impsel2 = 1'b1;

   assign pll_rst_n = 1'b1;

   assign clk_en = 1'b1;

   assign pll_lock = 1'b1;
   assign pll_bypass = 1'b1;
   assign pll_rangea = 5'b0;

   assign clk_mux_sel = 2'b0;

   assign jtag_clk = 1'b0;
   assign jtag_rst_l = 1'b1;
   assign jtag_modesel = 1'b1;
   assign jtag_datain = 1'b0;

   assign async_mux = 1'b1;

   assign oram_on = 1'b0;
   assign oram_traffic_gen = 1'b0;
   assign oram_dummy_gen = 1'b0;

   assign piton_prsnt_n = ~rst_n_inter_sync;
   assign piton_ready_n = ~rst_n_inter_sync;

`ifdef PITON_FPGA_CLKS_GEN
   assign leds[0] = mmcm_locked;
`else // ifndef PITON_FPGA_CLKS_GEN
   assign leds[0] = 1'b1;
`endif // endif PITON_FPGA_CLKS_GEN
   assign leds[1] = rst_n_inter_sync;
   assign leds[2] = io_clk_rst_n_inter_sync;
   assign leds[3] = processor_offchip_noc1_valid;
   assign leds[4] = processor_offchip_noc2_valid;
   assign leds[5] = offchip_processor_noc2_valid;
   assign leds[6] = offchip_processor_noc3_valid;
   assign leds[7] = 1'b0;

`endif // endif PITON_CHIP_FPGA

   // Connecting chip_bridge data to tiles/ORAM
<%
   s = '''
   assign proc_oram_valid = tile_0_0_out_N_noc2_valid;
   assign proc_oram_data = tile_0_0_out_N_noc2_data;
   assign oram_proc_yummy = tile_0_0_out_N_noc3_yummy;'''
   if (PITON_NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign proc_oram_valid = xbar_X_TILES_out_noc2_valid;
   assign proc_oram_data = xbar_X_TILES_out_noc2_data;
   assign oram_proc_yummy = xbar_X_TILES_out_noc3_yummy;'''

   elif PITON_NETWORK_CONFIG == "pyocn_config":
       s = pyocn_chip_utils.str_proc_oram()

   elif PITON_NETWORK_CONFIG == "pyocn_router_config":
       s = '''
   //---------------------------------------------------------------------
   // pyocn_router_config - does not need extra wiring here
   //---------------------------------------------------------------------'''

   print(s.replace("X_TILES", str(PITON_X_TILES)))
%>
`ifndef PITON_NO_CHIP_BRIDGE
   assign offchip_oram_valid = offchip_processor_noc3_valid;
   assign offchip_oram_data = offchip_processor_noc3_data;
   assign oram_offchip_yummy = processor_offchip_noc2_yummy;
`endif
<%
   s = r'''
   assign processor_offchip_noc1_valid = tile_0_0_out_N_noc1_valid;
   assign processor_offchip_noc1_data = tile_0_0_out_N_noc1_data;
   assign offchip_processor_noc1_yummy = tile_0_0_out_N_noc1_yummy;'''
   if (PITON_NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign processor_offchip_noc1_valid = xbar_X_TILES_out_noc1_valid;
   assign processor_offchip_noc1_data = xbar_X_TILES_out_noc1_data;
   assign offchip_processor_noc1_yummy = xbar_X_TILES_out_noc1_yummy;'''

   elif PITON_NETWORK_CONFIG == "pyocn_config":
       s = pyocn_chip_utils.str_processor_offchip_noc1()

   elif PITON_NETWORK_CONFIG == "pyocn_router_config":
       s = '''
   //---------------------------------------------------------------------
   // pyocn_router_config - does not need extra wiring here
   //---------------------------------------------------------------------'''

   print(s.replace("X_TILES", str(PITON_X_TILES)))
%>
`ifndef PITON_NO_CHIP_BRIDGE
   assign processor_offchip_noc2_valid = oram_offchip_valid;
   assign processor_offchip_noc2_data = oram_offchip_data;
`endif
<%
   s = r'''
   assign offchip_processor_noc2_yummy = tile_0_0_out_N_noc2_yummy;
   assign processor_offchip_noc3_valid = tile_0_0_out_N_noc3_valid;
   assign processor_offchip_noc3_data = tile_0_0_out_N_noc3_data;'''
   if (PITON_NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign offchip_processor_noc2_yummy = xbar_X_TILES_out_noc2_yummy;
   assign processor_offchip_noc3_valid = xbar_X_TILES_out_noc3_valid;
   assign processor_offchip_noc3_data = xbar_X_TILES_out_noc3_data;'''

   elif PITON_NETWORK_CONFIG == "pyocn_config":
       s = pyocn_chip_utils.str_processor_offchip_noc3()

   elif PITON_NETWORK_CONFIG == "pyocn_router_config":
       s = '''
   //---------------------------------------------------------------------
   // pyocn_router_config - does not need extra wiring here
   //---------------------------------------------------------------------'''

   print(s.replace("X_TILES", str(PITON_X_TILES)))
%>
   assign offchip_processor_noc3_yummy = offchip_oram_yummy;
<%
   s = r'''
   assign offchip_out_S_noc1_data = offchip_processor_noc1_data;
   assign offchip_out_S_noc1_valid = offchip_processor_noc1_valid;
   assign offchip_out_S_noc1_yummy = processor_offchip_noc1_yummy;
   assign offchip_out_S_noc2_data = offchip_processor_noc2_data;
   assign offchip_out_S_noc2_valid = offchip_processor_noc2_valid;
   assign offchip_out_S_noc2_yummy = proc_oram_yummy; //going to processor
   assign offchip_out_S_noc3_data = oram_proc_data;
   assign offchip_out_S_noc3_valid = oram_proc_valid;
   assign offchip_out_S_noc3_yummy = processor_offchip_noc3_yummy;'''
   if (PITON_NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign offchip_out_noc1_data = offchip_processor_noc1_data;
   assign offchip_out_noc1_valid = offchip_processor_noc1_valid;
   assign offchip_out_noc1_yummy = processor_offchip_noc1_yummy;
   assign offchip_out_noc2_data = offchip_processor_noc2_data;
   assign offchip_out_noc2_valid = offchip_processor_noc2_valid;
   assign offchip_out_noc2_yummy = proc_oram_yummy; //going to processor
   assign offchip_out_noc3_data = oram_proc_data;
   assign offchip_out_noc3_valid = oram_proc_valid;
   assign offchip_out_noc3_yummy = processor_offchip_noc3_yummy;'''

   elif PITON_NETWORK_CONFIG == "pyocn_config":
        s = pyocn_chip_utils.str_offchip_out()

   elif PITON_NETWORK_CONFIG == "pyocn_router_config":
        s = r'''
   //---------------------------------------------------------------------
   // pyocn_router_config - does not need extra offchip wiring
   //---------------------------------------------------------------------'''

   print(s)
%>

   // trin: off-chip channel mux when disabling oram
   always @ *
   begin
     // default is bypassing
     oram_offchip_valid = proc_oram_valid;
     oram_offchip_data = proc_oram_data;
     proc_oram_yummy = oram_offchip_yummy;
     oram_proc_valid = offchip_oram_valid;
     oram_proc_data = offchip_oram_data;
     offchip_oram_yummy = oram_proc_yummy;

     if (oram_on_inter)
     begin
       oram_offchip_valid = oram_offchip_valid_oram;
       oram_offchip_data = oram_offchip_data_oram;
       proc_oram_yummy = proc_oram_yummy_oram;
       oram_proc_valid = oram_proc_valid_oram;
       oram_proc_data = oram_proc_data_oram;
       offchip_oram_yummy = offchip_oram_yummy_oram;
     end
   end

   // Merge all JTAG outputs from tiles together
<%
   t0 = 'assign tiles_jtag_ucb_val ='
   t1 = 'assign tiles_jtag_ucb_data ='
   for i in range(PITON_X_TILES):
       for j in range(PITON_Y_TILES):
           currentid = (i, j);
           flatid = i + (j * PITON_X_TILES);
           if flatid == 0:
               t0 = t0 + ' tile%d_jtag_ucb_val' % flatid
               t1 = t1 + ' tile%d_jtag_ucb_data' % flatid
           else:
               t0 = t0 + ' | tile%d_jtag_ucb_val' % flatid
               t1 = t1 + ' | tile%d_jtag_ucb_data' % flatid
   t0 = t0 + ';'
   t1 = t1 + ';'
   print(t0)
   print(t1)
%>

// TODO: wiring of PRGA needs to be changed
<%
   template = r'''
   /////////////////////////
   // Extra wiring for PRGA
   /////////////////////////

   wire aclk, arst_n, urst_n;

   wire ureg_req_rdy, ureg_req_val, ureg_resp_rdy, ureg_resp_val;
   wire [`PRGA_CREG_ADDR_WIDTH-1:0] ureg_req_addr;
   wire [`PRGA_CREG_DATA_WIDTH-1:0] ureg_req_data, ureg_resp_data;
   wire [`PRGA_CREG_DATA_BYTES-1:0] ureg_req_strb;
   wire [`PRGA_ECC_WIDTH-1:0] ureg_resp_ecc;

   wire prga_awready, prga_awvalid;
   wire [`PRGA_AXI4_ID_WIDTH-1:0]       prga_awid;
   wire [`PRGA_AXI4_ADDR_WIDTH-1:0]     prga_awaddr;
   wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]    prga_awlen;
   wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]   prga_awsize;
   wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]  prga_awburst;
   wire [`PRGA_AXI4_AXCACHE_WIDTH-1:0]  prga_awcache;
   wire [`PRGA_CCM_ECC_WIDTH-1:0]       prga_awuser;
   wire prga_wready, prga_wvalid;
   wire [`PRGA_AXI4_DATA_WIDTH-1:0]     prga_wdata;
   wire [`PRGA_AXI4_DATA_BYTES-1:0]     prga_wstrb;
   wire                                 prga_wlast;
   wire [`PRGA_CCM_ECC_WIDTH-1:0]       prga_wuser;
   wire prga_bready, prga_bvalid;
   wire [`PRGA_AXI4_XRESP_WIDTH-1:0]    prga_bresp;
   wire [`PRGA_AXI4_ID_WIDTH-1:0]       prga_bid;
   wire prga_arready, prga_arvalid;
   wire [`PRGA_AXI4_ID_WIDTH-1:0]       prga_arid;
   wire [`PRGA_AXI4_ADDR_WIDTH-1:0]     prga_araddr;
   wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]    prga_arlen;
   wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]   prga_arsize;
   wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]  prga_arburst;
   wire                                 prga_arlock;
   wire [`PRGA_AXI4_AXCACHE_WIDTH-1:0]  prga_arcache;
   wire [`PRGA_CCM_AMO_OPCODE_WIDTH + `PRGA_CCM_ECC_WIDTH + `PRGA_CCM_DATA_WIDTH - 1:0]     prga_aruser;
   wire prga_rready, prga_rvalid;
   wire [`PRGA_AXI4_XRESP_WIDTH-1:0]    prga_rresp;
   wire [`PRGA_AXI4_ID_WIDTH-1:0]       prga_rid;
   wire [`PRGA_AXI4_DATA_WIDTH-1:0]     prga_rdata;
   wire                                 prga_rlast;

   wire prog_rst_n, prog_req_rdy, prog_req_val, prog_resp_rdy, prog_resp_val, prog_resp_err;
   wire [`PRGA_PROG_STATUS_WIDTH-1:0] prog_status;
   wire [`PRGA_CREG_ADDR_WIDTH-1:0] prog_req_addr;
   wire [`PRGA_CREG_DATA_WIDTH-1:0] prog_req_data, prog_resp_data;
   wire [`PRGA_CREG_DATA_BYTES-1:0] prog_req_strb;
   '''

   if PITON_PRGA:
       print(template);
%>

   /////////////////////////
   // Sub-module Instances
   /////////////////////////

   // Need to generate clocks from MMCM for standalone chip FPGA synthesis
`ifdef PITON_FPGA_CLKS_GEN
   // Generate core_ref_clk
   clk_mmcm_chip clk_mmcm (
      .clk_in1_p(clk_osc_p),
      .clk_in1_n(clk_osc_n),

      .reset(1'b0),
      .locked(mmcm_locked),

      .core_ref_clk(core_ref_clk)
   );
`endif // endif PITON_FPGA_CLKS_GEN

`ifndef PITON_NO_CHIP_BRIDGE
`ifdef PITON_CHIP_FPGA
   // Generate io_clk from input
   IBUFGDS #(.DIFF_TERM("TRUE")) intf_chip_clk_ibufgds(
      .I(intf_chip_clk_p),
      .IB(intf_chip_clk_n),
      .O(io_clk)
   );
   // Output io_clk to intf
   OBUFDS chip_intf_clk_obufds(
      .I(io_clk),
      .O(chip_intf_clk_p),
      .OB(chip_intf_clk_n)
   );

   // Differential to single ended conversion for interface
   OBUFDS chip_intf_data_obufds[31:0] (
      .I(chip_intf_data),
      .O(chip_intf_data_p),
      .OB(chip_intf_data_n)
   );
   OBUFDS chip_intf_channel_obufds[1:0] (
      .I(chip_intf_channel),
      .O(chip_intf_channel_p),
      .OB(chip_intf_channel_n)
   );
   IBUFDS  #(.DIFF_TERM("TRUE")) chip_intf_credit_back_ibufds[2:0] (
      .I(chip_intf_credit_back_p),
      .IB(chip_intf_credit_back_n),
      .O(chip_intf_credit_back)
   );
   IBUFDS #(.DIFF_TERM("TRUE")) intf_chip_data_ibufds[31:0] (
      .I(intf_chip_data_p),
      .IB(intf_chip_data_n),
      .O(intf_chip_data)
   );
   IBUFDS #(.DIFF_TERM("TRUE")) intf_chip_channel_ibufds[1:0] (
      .I(intf_chip_channel_p),
      .IB(intf_chip_channel_n),
      .O(intf_chip_channel)
   );
   OBUFDS intf_chip_credit_back_obufds[2:0] (
      .I(intf_chip_credit_back),
      .O(intf_chip_credit_back_p),
      .OB(intf_chip_credit_back_n)
   );
`endif // endif PITON_CHIP_FPGA
`endif // endif PITON_NO_CHIP_BRIDGE

   // Off-Chip Interface Block

   OCI oci_inst (
   // Outside
   .slew                (slew),
   .impsel1                (impsel1),
   .impsel2                (impsel2),
   .core_ref_clk           (core_ref_clk),
   .io_clk                 (io_clk),
`ifndef PITON_CHIP_FPGA
   .rst_n                  (rst_n),
`else // ifndef PITON_CHIP_FPGA
   .rst_n                       (rst_n & (~chipset_prsnt_n)),
`endif
   .pll_rst_n              (pll_rst_n),
   .pll_rangea             (pll_rangea),
   .clk_mux_sel               (clk_mux_sel),
   .clk_en                 (clk_en),
   .pll_bypass             (pll_bypass),
   .async_mux              (async_mux),
   .oram_on                (oram_on),
   .oram_traffic_gen       (oram_traffic_gen),
   .oram_dummy_gen            (oram_dummy_gen),
   .pll_lock               (pll_lock),
   .jtag_clk               (jtag_clk),
   .jtag_rst_l             (jtag_rst_l),
   .jtag_modesel           (jtag_modesel),
   .jtag_datain               (jtag_datain),
   .jtag_dataout           (jtag_dataout),
`ifndef PITON_NO_CHIP_BRIDGE
   .intf_chip_data            (intf_chip_data),
   .intf_chip_channel         (intf_chip_channel),
   .intf_chip_credit_back     (intf_chip_credit_back),
   .chip_intf_data            (chip_intf_data),
   .chip_intf_channel         (chip_intf_channel),
   .chip_intf_credit_back     (chip_intf_credit_back),
`else // ifdef PITON_NO_CHIP_BRIDGE
   .intf_chip_data              (),
   .intf_chip_channel           (),
   .intf_chip_credit_back       (),
   .chip_intf_data              (),
   .chip_intf_channel           (),
   .chip_intf_credit_back       (),
`endif // endif PITON_NO_CHIP_BRIDGE
   // Inside
   .core_ref_clk_inter        (core_ref_clk_inter),
   .io_clk_inter           (io_clk_inter),
   .rst_n_inter               (rst_n_inter),
   .pll_rst_n_inter           (pll_rst_n_inter),
   .pll_rangea_inter       (pll_rangea_inter),
   .clk_mux_sel_inter         (clk_mux_sel_inter),
   .clk_en_inter           (clk_en_inter),
   .pll_bypass_inter       (pll_bypass_inter),
   .async_mux_inter           (async_mux_inter),
   .oram_on_inter          (oram_on_inter),
   .oram_traffic_gen_inter    (oram_traffic_gen_inter),
   .oram_dummy_gen_inter      (oram_dummy_gen_inter),
   .pll_lock_inter            (pll_lock_inter),
   .jtag_clk_inter            (jtag_clk_inter),
   .jtag_rst_l_inter       (jtag_rst_l_inter),
   .jtag_modesel_inter        (jtag_modesel_inter),
   .jtag_datain_inter         (jtag_datain_inter),
   .jtag_dataout_inter        (jtag_dataout_inter),
   .intf_chip_data_inter      (intf_chip_data_inter),
   .intf_chip_channel_inter      (intf_chip_channel_inter),
   .intf_chip_credit_back_inter  (intf_chip_credit_back_inter),
   .chip_intf_data_inter      (chip_intf_data_inter),
   .chip_intf_channel_inter      (chip_intf_channel_inter),
   .chip_intf_credit_back_inter  (chip_intf_credit_back_inter) );

`ifndef PITON_PLL_BSG_CLK_GEN
   // PLL and clock mux.  See above for alternatives
   clk_se_to_diff ref_clk_converter (
       .clk_se  (core_ref_clk_inter),
       .clk_p   (core_ref_clk_inter_t),
       .clk_n   (core_ref_clk_inter_c)
   );
   clk_mux clock_mux (
       .clk0_p(core_ref_clk_inter_t),
       .clk0_n(core_ref_clk_inter_c),
       .clk1_p(1'b1),
       .clk1_n(1'b0),
       .clk2(pll_clk),

       .sel(clk_mux_sel_inter),

       .clk_muxed(clk_muxed)
   );
   pll_top pll_top (
      .clk_locked(pll_lock_inter),
      .clk_out(pll_clk),

      .rangeA(pll_rangea_inter),
      .bypass_en(pll_bypass_inter),
      .ref_clk(core_ref_clk_inter),
      .rst(~pll_rst_n_inter)
   );
`else
   // Clock generator, incl. clock mux.  See above for alternatives
   clk_gen_wrapper clk_gen_wrapper (
      .clk_tag_clk_i(pll_rangea_inter[2]),
      .clk_tag_en_i(pll_rangea_inter[3]),
      .clk_tag_data_i(pll_rangea_inter[4]),

      .clk_byp_i(core_ref_clk_inter),

      .clk_sel_i(clk_mux_sel_inter),

      .clk_o(clk_muxed),

      .clk_monitor_slow_i(oram_on_inter),
      .clk_monitor_o(pll_lock_inter)
   );
`endif

   // reset synchronizer, might need to be placed near the
   //   pll or clock source so that reset signal has the same propagation
   //   as clock for better timing
   // materials on reset tree and placement
   // http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_Resets.pdf
   synchronizer rst_sync (
      .clk(clk_muxed),
      .presyncdata(rst_n_inter),
      .syncdata(rst_n_inter_sync)
   );
   synchronizer io_clk_rst_sync (
      .clk(io_clk_inter),
      .presyncdata(rst_n_inter),
      .syncdata(io_clk_rst_n_inter_sync)
   );
   synchronizer jtag_rst_sync (
      .clk(clk_muxed),
      .presyncdata(jtag_rst_l_inter),
      .syncdata(jtag_rst_l_inter_sync)
   );

`ifndef PITON_NO_CHIP_BRIDGE
   // Chip to FPGA bridge
   chip_bridge chip_intf(
       // Xilinx afifos want asynchronous reset, so need to passs that in
       // and do internal synchronizeation
`ifdef PITON_PROTO
       .rst_n                  (rst_n_inter),
`else // ifndef PITON_FPGA_SYNTH
       .rst_n                  (rst_n_inter_sync_ff),
`endif
       .chip_clk               (clk_muxed),
       .intcnct_clk            (io_clk_inter),
       .async_mux              (async_mux_inter),
       .network_out_1          (chip_intf_noc1_data),
       .network_out_2          (chip_intf_noc2_data),
       .network_out_3          (chip_intf_noc3_data),
       .data_out_val_1         (chip_intf_noc1_valid),
       .data_out_val_2         (chip_intf_noc2_valid),
       .data_out_val_3         (chip_intf_noc3_valid),
       .data_out_rdy_1         (chip_intf_noc1_rdy),
       .data_out_rdy_2         (chip_intf_noc2_rdy),
       .data_out_rdy_3         (chip_intf_noc3_rdy),
       .intcnct_data_in        (intf_chip_data_inter_buf_f),
       .intcnct_channel_in     (intf_chip_channel_inter_buf_f),
       .intcnct_credit_back_in (intf_chip_credit_back_inter),
       .network_in_1           (intf_chip_noc1_data),
       .network_in_2           (intf_chip_noc2_data),
       .network_in_3           (intf_chip_noc3_data),
       .data_in_val_1          (intf_chip_noc1_valid),
       .data_in_val_2          (intf_chip_noc2_valid),
       .data_in_val_3          (intf_chip_noc3_valid),
       .data_in_rdy_1          (intf_chip_noc1_rdy),
       .data_in_rdy_2          (intf_chip_noc2_rdy),
       .data_in_rdy_3          (intf_chip_noc3_rdy),
       .intcnct_data_out       (chip_intf_data_inter),
       .intcnct_channel_out    (chip_intf_channel_inter),
       .intcnct_credit_back_out(chip_intf_credit_back_inter_buf_f)
   );
`endif // endif PITON_NO_CHIP_BRIDGE

   // Chip Bridge val/rdy to credit
<%
   s = r'''
   `ifdef PITON_NO_CHIP_BRIDGE
   credit_to_valrdy chip_from_intf_noc1_v2c(
      .clk(clk_muxed),
      .reset(~rst_n_inter_sync_ff),
      .data_out(intf_chip_noc1_data),
      .valid_out(intf_chip_noc1_valid),
      .ready_out(intf_chip_noc1_rdy),

      .data_in(offchip_processor_noc1_data),           // Data
      .valid_in(offchip_processor_noc1_valid),       // Val signal
      .yummy_in(offchip_processor_noc1_yummy)    // Yummy signal
   );

   valrdy_to_credit #(4, 3) chip_to_intf_noc1_c2v(
      .clk(clk_muxed),
      .reset(~rst_n_inter_sync_ff),
      .data_out(processor_offchip_noc1_data),
      .valid_out(processor_offchip_noc1_valid),
      .yummy_out(processor_offchip_noc1_yummy),

      .data_in(chip_intf_noc1_data),           // Data
      .valid_in(chip_intf_noc1_valid),       // Val signal from dynamic network to processor
      .ready_in(chip_intf_noc1_rdy)    // Rdy signal from processor to dynamic network
   );

   credit_to_valrdy chip_from_intf_noc2_v2c(
      .clk(clk_muxed),
      .reset(~rst_n_inter_sync_ff),
      .data_out(intf_chip_noc2_data),
      .valid_out(intf_chip_noc2_valid),
      .ready_out(intf_chip_noc2_rdy),

      .data_in(offchip_processor_noc2_data),           // Data
      .valid_in(offchip_processor_noc2_valid),       // Val signal
      .yummy_in(offchip_processor_noc2_yummy)    // Yummy signal
   );

   valrdy_to_credit #(4, 3) chip_to_intf_noc2_c2v(
      .clk(clk_muxed),
      .reset(~rst_n_inter_sync_ff),
      .data_out(processor_offchip_noc2_data),
      .valid_out(processor_offchip_noc2_valid),
      .yummy_out(processor_offchip_noc2_yummy),

      .data_in(chip_intf_noc2_data),           // Data
      .valid_in(chip_intf_noc2_valid),       // Val signal from dynamic network to processor
      .ready_in(chip_intf_noc2_rdy)    // Rdy signal from processor to dynamic network
   );

   credit_to_valrdy chip_from_intf_noc3_v2c(
      .clk(clk_muxed),
      .reset(~rst_n_inter_sync_ff),
      .data_out(intf_chip_noc3_data),
      .valid_out(intf_chip_noc3_valid),
      .ready_out(intf_chip_noc3_rdy),

      .data_in(offchip_processor_noc3_data),           // Data
      .valid_in(offchip_processor_noc3_valid),       // Val signal
      .yummy_in(offchip_processor_noc3_yummy)    // Yummy signal
   );

   valrdy_to_credit #(4, 3) chip_to_intf_noc3_c2v(
      .clk(clk_muxed),
      .reset(~rst_n_inter_sync_ff),
      .data_out(processor_offchip_noc3_data),
      .valid_out(processor_offchip_noc3_valid),
      .yummy_out(processor_offchip_noc3_yummy),

      .data_in(chip_intf_noc3_data),           // Data
      .valid_in(chip_intf_noc3_valid),       // Val signal from dynamic network to processor
      .ready_in(chip_intf_noc3_rdy)    // Rdy signal from processor to dynamic network
   );
   `endif'''

   #if PITON_NETWORK_CONFIG == "pyocn_config" or PITON_NETWORK_CONFIG == "pyocn_router_config":
   #    s = r'''
   #//---------------------------------------------------------------------
   #// pyocn_config - does not need the val/rdy-credit adapters
   #//---------------------------------------------------------------------'''

   print(s)
%>

   // on-chip jtag interface & test access port
   jtag jtag_port(
      .clk(clk_muxed),
      .rst_n(rst_n_inter_sync_ff),
      .jtag_clk(jtag_clk_inter),
      .jtag_rst_l(jtag_rst_l_inter_sync),
      .jtag_modesel(jtag_modesel_inter),
      .jtag_datain(jtag_datain_inter),
      .jtag_dataout(jtag_dataout_inter),
      .jtag_dataout_en(),
      .jtag_tiles_ucb_val(jtag_tiles_ucb_val),
      .jtag_tiles_ucb_data(jtag_tiles_ucb_data),
      .tiles_jtag_ucb_val(tiles_jtag_ucb_val),
      .tiles_jtag_ucb_data(tiles_jtag_ucb_data),

      .ctap_oram_req_val(ctap_oram_req_val),
      .ctap_oram_req_misc(ctap_oram_req_misc),
      .oram_ctap_res_data(oram_ctap_res_data),
      // .ctap_oram_bist_command(ctap_oram_bist_command),
      // .ctap_oram_bist_data(ctap_oram_bist_data),
      // .oram_ctap_sram_data(oram_ctap_sram_data),

      .ctap_clk_en(ctap_clk_en_inter),
      .ctap_oram_clk_en(ctap_oram_clk_en)
   );

   // generate the cross bars
<%
   if (PITON_NETWORK_CONFIG == "xbar_config"):
       xbartemplate = r'''
       dynamic_node_top_wrap_para xbar_noc1(
           .clk                (clk_muxed),
           .reset_in           (~rst_n_inter_sync_ff),

           .myChipID                   (14'b0),    // the first chip
           .myLocX                     (8'b0),  // not used
           .myLocY                     (8'b0),  // not used
       '''

       for i in range (PITON_X_TILES):
           for j in range (PITON_Y_TILES):
               xbartemplate += "    .dataIn_%d(tile_%d_%d_out_noc1_data),\n"  % (i, j,i)
               xbartemplate += "    .validIn_%d(tile_%d_%d_out_noc1_valid),\n"  % (i, j,i)
               xbartemplate += "    .yummyIn_%d(tile_%d_%d_out_noc1_yummy),\n"  % (i, j,i)
               xbartemplate += "    .dataOut_%d(xbar_%d_out_noc1_data),\n"  % (i, i)
               xbartemplate += "    .validOut_%d(xbar_%d_out_noc1_valid),\n"  % (i, i)
               xbartemplate += "    .yummyOut_%d(xbar_%d_out_noc1_yummy),\n\n"  % (i, i)

       xbartemplate += "    .dataIn_%d(offchip_out_noc1_data),\n"  % PITON_X_TILES
       xbartemplate += "    .validIn_%d(offchip_out_noc1_valid),\n"  % PITON_X_TILES
       xbartemplate += "    .yummyIn_%d(offchip_out_noc1_yummy),\n"  % PITON_X_TILES
       xbartemplate += "    .dataOut_%d(xbar_%d_out_noc1_data),\n"  % (PITON_X_TILES, PITON_X_TILES)
       xbartemplate += "    .validOut_%d(xbar_%d_out_noc1_valid),\n"  % (PITON_X_TILES, PITON_X_TILES)
       xbartemplate += "    .yummyOut_%d(xbar_%d_out_noc1_yummy),\n\n"  % (PITON_X_TILES, PITON_X_TILES)
       xbartemplate += "    .thanksIn_%d();\n" % (PITON_X_TILES)
       xbartemplate = xbartemplate[:-2] + r'''
       );'''

       print(xbartemplate)
       print(xbartemplate.replace("noc1", "noc2"))
       print(xbartemplate.replace("noc1", "noc3"))

   elif PITON_NETWORK_CONFIG == "pyocn_config":
       pyocn_chip_utils.print_pyocn_instances()

%>

`ifdef PITON_ARIANE
`ifdef PITON_RVIC
    // Added by Kaifeng Xu
    // flop interrupt long wires from PRGA control tiles to ariane tiles
    reg [`PITON_RV64_TILES * 2 - 1: 0]   irq_f;
    reg [`PITON_RV64_TILES * 2 - 1: 0]   irq_ff;
    reg [`PITON_RV64_TILES - 1 : 0]      timer_irq_f;
    reg [`PITON_RV64_TILES - 1 : 0]      timer_irq_ff;
    reg [`PITON_RV64_TILES - 1 : 0]      ipi_f;
    reg [`PITON_RV64_TILES - 1 : 0]      ipi_ff;
    always @(posedge clk_muxed) begin
        if (~rst_n_inter_sync_ff) begin
	        irq_f        <= {`PITON_RV64_TILES*2{1'b0}};
	        irq_ff       <= {`PITON_RV64_TILES*2{1'b0}};
	        timer_irq_f  <= {`PITON_RV64_TILES{1'b0}};
	        timer_irq_ff <= {`PITON_RV64_TILES{1'b0}};
	        ipi_f        <= {`PITON_RV64_TILES{1'b0}};
	        ipi_ff       <= {`PITON_RV64_TILES{1'b0}};
	    end
	    else begin
	        irq_f        <= irq;
	        irq_ff       <= irq_f;
	        timer_irq_f  <= timer_irq;
	        timer_irq_ff <= timer_irq_f;
	        ipi_f        <= ipi;
	        ipi_ff       <= ipi_f;
	    end
    end
`endif
`endif

    wire [31:0] default_total_num_tiles;
    assign default_total_num_tiles = `PITON_NUM_TILES;
    // Generate tile instances
<%
    # Notes:
    #
    #   Additional templating is added below, specifically:
    #       _TILE_ is used to instantiate `prga_ctrl_tile`
    #       _PRGA_ADDITIONAL_WIRES_ is used to add ports specific to `prga_ctrl_tile`

    template = r'''
    reg rst_n_inter_sync_tile0_f, rst_n_inter_sync_tile0_ff;
    always @(posedge clk_muxed) begin
        rst_n_inter_sync_tile0_f <= rst_n_inter_sync;
        rst_n_inter_sync_tile0_ff <= rst_n_inter_sync_tile0_f;
    end

    _TILE_ #(.TILE_TYPE(TYPE_OF_TILE))
    tile0 (
        .clk                (clk_muxed),
        .rst_n              (rst_n_inter_sync_tile0_ff),
        .clk_en             (ctap_clk_en_inter[_FLAT_ID_] && clk_en_inter),
        .default_chipid             (14'b0),    // the first chip
        .default_coreid_x           (COREIDX),
        .default_coreid_y           (COREIDY),
        .default_total_num_tiles    (default_total_num_tiles      ),
        .flat_tileid                (`JTAG_FLATID_WIDTH'd_FLAT_ID_),
        _ARIANE_INT_WIRES_
        _RVIC_WIRES_
        // ucb from tiles to jtag
        .tile_jtag_ucb_val   ( tile0_jtag_ucb_val      ),
        .tile_jtag_ucb_data  ( tile0_jtag_ucb_data     ),
        // ucb from jtag to tiles
        .jtag_tiles_ucb_val  ( jtag_tiles_ucb_val      ),
        .jtag_tiles_ucb_data ( jtag_tiles_ucb_data     ),
    '''

    subtemplate = r'''
        .dyn0_dataIn_N       ( in_N_noc1_data   ),
        .dyn0_dataIn_E       ( in_E_noc1_data   ),
        .dyn0_dataIn_W       ( in_W_noc1_data   ),
        .dyn0_dataIn_S       ( in_S_noc1_data   ),
        .dyn0_validIn_N      ( in_N_noc1_valid  ),
        .dyn0_validIn_E      ( in_E_noc1_valid  ),
        .dyn0_validIn_W      ( in_W_noc1_valid  ),
        .dyn0_validIn_S      ( in_S_noc1_valid  ),
        .dyn0_dNo_yummy      ( in_N_noc1_yummy  ),
        .dyn0_dEo_yummy      ( in_E_noc1_yummy  ),
        .dyn0_dWo_yummy      ( in_W_noc1_yummy  ),
        .dyn0_dSo_yummy      ( in_S_noc1_yummy  ),

        .dyn0_dNo            ( out_N_noc1_data  ),
        .dyn0_dEo            ( out_E_noc1_data  ),
        .dyn0_dWo            ( out_W_noc1_data  ),
        .dyn0_dSo            ( out_S_noc1_data  ),
        .dyn0_dNo_valid      ( out_N_noc1_valid ),
        .dyn0_dEo_valid      ( out_E_noc1_valid ),
        .dyn0_dWo_valid      ( out_W_noc1_valid ),
        .dyn0_dSo_valid      ( out_S_noc1_valid ),
        .dyn0_yummyOut_N     ( out_N_noc1_yummy ),
        .dyn0_yummyOut_E     ( out_E_noc1_yummy ),
        .dyn0_yummyOut_W     ( out_W_noc1_yummy ),
        .dyn0_yummyOut_S     ( out_S_noc1_yummy ),'''
        #.ec_dyn0            (                  ),'''
    if (PITON_NETWORK_CONFIG == "xbar_config"):
        subtemplate = r'''
        .dyn0_dataIn         ( in_noc1_data     ),
        .dyn0_validIn        ( in_noc1_valid    ),
        .dyn0_do_yummy       ( in_noc1_yummy    ),
        .dyn0_do             ( out_noc1_data    ),
        .dyn0_do_valid       ( out_noc1_valid   ),
        .dyn0_yummyOut       ( out_noc1_yummy   ),'''

    if (PITON_NETWORK_CONFIG != "pyocn_router_config"):
        sub2 = subtemplate.replace('dyn0', 'dyn1');
        sub2 = sub2.replace("noc1", "noc2");
        sub3 = subtemplate.replace('dyn0', 'dyn2');
        sub3 = sub3.replace("noc1", "noc3");

        template += subtemplate + sub2 + sub3;
        template = template[:-1] + r'''_PRGA_ADDITIONAL_WIRES_
    );
    '''

    # generate the tiles
    for i in range(PITON_X_TILES):
        for j in range(PITON_Y_TILES):
            currentid = (i, j);
            flatid = i + (j * PITON_X_TILES);
            # print template
            currenttile = template.replace("tile0", "tile%d" % (flatid));
            currenttile = currenttile.replace("COREIDX", "8'd" + repr(i));
            currenttile = currenttile.replace("COREIDY", "8'd" + repr(j));
            currenttile = currenttile.replace("out_", "tile_%d_%d_out_" % (j,i));
            currenttile = currenttile.replace("_FLAT_ID_", repr(flatid));

            if (DECADES_CHIP):
               if (i == PRGA_CTRL_X_TILE) and (j == PRGA_CTRL_Y_TILE):
                  currenttype = "`PRGA_TILE"
               elif (j % 2 == 0):
                  currenttype = "`ARIANE_RV64_TILE"
               elif (j % 4 == 3):
                  currenttype = "`DECADES_IS_TILE"
               else: #(j % 4 == 1)
                  if (i % 2 == 0):
                     currenttype = "`DECADES_ACC_GEMM_TILE"
                  else:
                     currenttype = "`DECADES_ACC_CONV2D_TILE"
            elif (DECADES_DECOUPLING):
               if (flatid % 4) == 1:
                  #Create an IS Tile every 4 tiles
                  currenttype = "`DECADES_IS_TILE"
               else:
                  currenttype = "`ARIANE_RV64_TILE"
            elif (PITON_PICO_HET):
               if (flatid % 2) == 0:
                  currenttype = "`SPARC_TILE"
               else:
                  currenttype = "`PICORV32_TILE"
            elif (PITON_PICO):
                currenttype = "`PICORV32_TILE"
            elif (PITON_PRGA):
                if i == PITON_X_TILES - 1 and j == PITON_Y_TILES - 1:
                    currenttype = "`PRGA_TILE"
                else:
                    currenttype = "`ARIANE_RV64_TILE"
            elif (PITON_ARIANE):
                currenttype = "`ARIANE_RV64_TILE"
            elif (PITON_NIBBLER):
                currenttype = "`NIBBLER_TILE"
            else:
                currenttype = "`SPARC_TILE"

            currenttile = currenttile.replace("TYPE_OF_TILE", currenttype)

            if (PITON_NETWORK_CONFIG == "xbar_config"):
                currenttile = currenttile.replace("in_", "xbar_%d_out_" % i);

            elif PITON_NETWORK_CONFIG == "pyocn_config":
                currenttile = pyocn_chip_utils.str_tile_template( j, i, PITON_X_TILES, currenttype )

            elif PITON_NETWORK_CONFIG == "pyocn_router_config":
                currenttile += pyocn_chip_utils.str_router_tile_template( j, i, PITON_Y_TILES, PITON_X_TILES, currenttype )
                currenttile = currenttile[:-1] + r'''_PRGA_ADDITIONAL_WIRES_
    );
    '''

            else:
                # now put in the data in direction
                if (j != 0):
                    idN = "tile_%d_%d" % (j-1, i)
                else:
                    idN = "dummy"

                if (j != PITON_Y_TILES - 1):
                    idS = "tile_%d_%d" % (j+1, i)
                else:
                    idS = "dummy"

                if (i != 0):
                    idW = "tile_%d_%d" % (j, i-1)
                else:
                    idW = "dummy"

                if (i != PITON_X_TILES - 1):
                    idE = "tile_%d_%d" % (j, i+1)
                else:
                    idE = "dummy"

                # special case for core 0
                if i == 0 and j == 0:
                    idN = "offchip"
                    idW = "dummy"

                currenttile = currenttile.replace("in_N", idN + "_out_S");
                currenttile = currenttile.replace("in_S", idS + "_out_N");
                currenttile = currenttile.replace("in_E", idE + "_out_W");
                currenttile = currenttile.replace("in_W", idW + "_out_E");
            
            # Interrupts wires for ariane cores
            if currenttype == "`ARIANE_RV64_TILE":
                currenttile = currenttile.replace("_ARIANE_INT_WIRES_", r'''
                    `ifndef PITON_RVIC

                    // RV64 debug and rvic signals come from chipset 
                    `ifdef PITON_RV64_PLATFORM
                    `ifdef PITON_RV64_DEBUGUNIT
                        .debug_req_i         ( debug_req_i[_RV64FLAT_ID_]   ),
                        .unavailable_o       ( unavailable_o[_RV64FLAT_ID_] ),
                    `endif // ifdef PITON_RV64_DEBUGUNIT
                    `ifdef PITON_RV64_CLINT
                        .timer_irq_i         ( timer_irq_i[_RV64FLAT_ID_]   ),
                        .ipi_i               ( ipi_i[_RV64FLAT_ID_]         ),
                    `endif // ifdef PITON_RV64_CLINT
                    `ifdef PITON_RV64_PLIC
                        .irq_i               ( irq_i[_RV64FLAT_ID_*2 +: 2]  ),
                    `endif // ifdef PITON_RV64_PLIC
                    `endif // ifdef PITON_RV64_PLATFORM
                    
                    `else // ifndef PITON_RVIC 
                        .timer_irq_i         ( timer_irq_ff[_RV64FLAT_ID_]   ),
                        .ipi_i               ( ipi_ff[_RV64FLAT_ID_]         ),
                        .irq_i               ( irq_ff[_RV64FLAT_ID_*2 +: 2]  ),
                    `endif // ifndef PITON_RVIC else
               ''')
            else:
               currenttile = currenttile.replace("_ARIANE_INT_WIRES_", "")

            _TILE_map = { 
               "`PRGA_TILE" : "prga_ctrl_tile" , 
               "`DECADES_IS_TILE" : "is_tile" , 
               "`ARIANE_RV64_TILE" : "tile" , 
               "`DECADES_ACC_GEMM_TILE" : "acc_gemm_tile" ,
               "`DECADES_ACC_CONV2D_TILE" : "acc_conv2d_tile" 
            }
            currenttile = currenttile.replace("_TILE_", _TILE_map[currenttype])

            if currenttype == "`PRGA_TILE":
                currenttile = currenttile.replace("_PRGA_ADDITIONAL_WIRES_", r"""
        ,.prog_rst_n                            (prog_rst_n)
        ,.prog_status                           (prog_status)
        ,.prog_req_rdy                          (prog_req_rdy)
        ,.prog_req_val                          (prog_req_val)
        ,.prog_req_addr                         (prog_req_addr)
        ,.prog_req_strb                         (prog_req_strb)
        ,.prog_req_data                         (prog_req_data)
        ,.prog_resp_rdy                         (prog_resp_rdy)
        ,.prog_resp_val                         (prog_resp_val)
        ,.prog_resp_err                         (prog_resp_err)
        ,.prog_resp_data                        (prog_resp_data)

        ,.aclk                                  (aclk)
        ,.arst_n                                (arst_n)

        ,.urst_n                                (urst_n)
        ,.ureg_req_rdy                          (ureg_req_rdy)
        ,.ureg_req_val                          (ureg_req_val)
        ,.ureg_req_addr                         (ureg_req_addr)
        ,.ureg_req_strb                         (ureg_req_strb)
        ,.ureg_req_data                         (ureg_req_data)
        ,.ureg_resp_rdy                         (ureg_resp_rdy)
        ,.ureg_resp_val                         (ureg_resp_val)
        ,.ureg_resp_data                        (ureg_resp_data)
        ,.ureg_resp_ecc                         (ureg_resp_ecc)

        ,.awready						        (prga_awready)
        ,.awvalid						        (prga_awvalid)
        ,.awid						            (prga_awid)
        ,.awaddr						        (prga_awaddr)
        ,.awlen						            (prga_awlen)
        ,.awsize						        (prga_awsize)
        ,.awburst						        (prga_awburst)
        ,.awcache						        (prga_awcache)
        ,.awuser						        (prga_awuser)
        ,.wready						        (prga_wready)
        ,.wvalid						        (prga_wvalid)
        ,.wdata						            (prga_wdata)
        ,.wstrb						            (prga_wstrb)
        ,.wlast						            (prga_wlast)
        ,.wuser						            (prga_wuser)
        ,.bready						        (prga_bready)
        ,.bvalid						        (prga_bvalid)
        ,.bresp						            (prga_bresp)
        ,.bid						            (prga_bid)
        ,.arready						        (prga_arready)
        ,.arvalid						        (prga_arvalid)
        ,.arid						            (prga_arid)
        ,.araddr						        (prga_araddr)
        ,.arlen						            (prga_arlen)
        ,.arsize						        (prga_arsize)
        ,.arburst						        (prga_arburst)
        ,.arlock						        (prga_arlock)
        ,.arcache						        (prga_arcache)
        ,.aruser						        (prga_aruser)
        ,.rready						        (prga_rready)
        ,.rvalid						        (prga_rvalid)
        ,.rresp						            (prga_rresp)
        ,.rid						            (prga_rid)
        ,.rdata						            (prga_rdata)
        ,.rlast						            (prga_rlast)

                """)
            # only one RVIC on PRGA tile
                currenttile = currenttile.replace("_RVIC_WIRES_", r'''
        `ifdef PITON_RVIC
        .irq_o               ( irq          ),
        .timer_irq_o         ( timer_irq    ),
        .ipi_o               ( ipi          ),
        `endif
                ''')
            else:
                currenttile = currenttile.replace("_PRGA_ADDITIONAL_WIRES_", "")
                currenttile = currenttile.replace("_RVIC_WIRES_", "")

            if (DECADES_CHIP):
                if (currenttype == "`ARIANE_RV64_TILE"):
                    rv64_flatid = (j // 2) * PITON_X_TILES + i
                    currenttile = currenttile.replace("_RV64FLAT_ID_", repr( rv64_flatid ));
                else:
                    currenttile = currenttile.replace("_RV64FLAT_ID_", repr(PITON_RV64_TILES-1)); # the last one
            elif (DECADES_DECOUPLING):
                if (flatid % 4) >= 1:
                    currenttile = currenttile.replace("_RV64FLAT_ID_", repr(flatid - int(flatid/4) - 1));
                    #Create an IS Tile every 4 tiles
                else:
                    currenttile = currenttile.replace("_RV64FLAT_ID_", repr(flatid - int(flatid/4) ));
            elif (PITON_PRGA):
                currenttile = currenttile.replace("_RV64FLAT_ID_", repr( min(flatid, PITON_X_TILES * PITON_Y_TILES - 1) ));
            else:
                currenttile = currenttile.replace("_RV64FLAT_ID_", repr( flatid ));



            # print "`ifdef RTL_SPARC%d" % flatid
            print(currenttile)
            # print "`endif"
%>

`ifdef PITON_PRGA
`ifdef PITON_PRGA_MOCK_APP

    /////////////////////////
    // Mock App for PRGA
    /////////////////////////

    assign prog_status = `PRGA_PROG_STATUS_DONE;
    assign prog_req_rdy = 1'b0;
    assign prog_resp_val = 1'b0;
    assign prog_resp_err = 1'b0;
    assign prog_resp_data = {`PRGA_CREG_DATA_WIDTH {1'b0} };

    `PITON_PRGA_MOCK_APP i_prga_mock_app (
       .clk                                 (aclk)
       ,.rst_n                              (urst_n)

       ,.ureg_req_rdy                       (ureg_req_rdy)
       ,.ureg_req_val                       (ureg_req_val)
       ,.ureg_req_addr                      (ureg_req_addr)
       ,.ureg_req_strb                      (ureg_req_strb)
       ,.ureg_req_data                      (ureg_req_data)
       ,.ureg_resp_rdy                      (ureg_resp_rdy)
       ,.ureg_resp_val                      (ureg_resp_val)
       ,.ureg_resp_data                     (ureg_resp_data)
       ,.ureg_resp_ecc                      (ureg_resp_ecc)

       ,.awready						    (prga_awready)
       ,.awvalid						    (prga_awvalid)
       ,.awid						        (prga_awid)
       ,.awaddr						        (prga_awaddr)
       ,.awlen						        (prga_awlen)
       ,.awsize						        (prga_awsize)
       ,.awburst						    (prga_awburst)
       ,.awcache						    (prga_awcache)
       ,.awuser						        (prga_awuser)
       ,.wready						        (prga_wready)
       ,.wvalid						        (prga_wvalid)
       ,.wdata						        (prga_wdata)
       ,.wstrb						        (prga_wstrb)
       ,.wlast						        (prga_wlast)
       ,.wuser						        (prga_wuser)
       ,.bready						        (prga_bready)
       ,.bvalid						        (prga_bvalid)
       ,.bresp						        (prga_bresp)
       ,.bid						        (prga_bid)
       ,.arready						    (prga_arready)
       ,.arvalid						    (prga_arvalid)
       ,.arid						        (prga_arid)
       ,.araddr						        (prga_araddr)
       ,.arlen						        (prga_arlen)
       ,.arsize						        (prga_arsize)
       ,.arburst						    (prga_arburst)
       ,.arlock						        (prga_arlock)
       ,.arcache						    (prga_arcache)
       ,.aruser						        (prga_aruser)
       ,.rready						        (prga_rready)
       ,.rvalid						        (prga_rvalid)
       ,.rresp						        (prga_rresp)
       ,.rid						        (prga_rid)
       ,.rdata						        (prga_rdata)
       ,.rlast						        (prga_rlast)

       );

`else /* PITON_PRGA_MOCK_APP */

    /////////////////////////
    // PRGA fabric
    /////////////////////////

    prga_fabric_wrap i_prga_fabric (
       .prog_clk                            (clk_muxed)
       ,.prog_rst_n                         (prog_rst_n)
       ,.prog_status                        (prog_status)
       ,.prog_req_rdy                       (prog_req_rdy)
       ,.prog_req_val                       (prog_req_val)
       ,.prog_req_addr                      (prog_req_addr)
       ,.prog_req_strb                      (prog_req_strb)
       ,.prog_req_data                      (prog_req_data)
       ,.prog_resp_rdy                      (prog_resp_rdy)
       ,.prog_resp_val                      (prog_resp_val)
       ,.prog_resp_err                      (prog_resp_err)
       ,.prog_resp_data                     (prog_resp_data)

       ,.uclk                               (aclk)
       ,.urst_n                             (urst_n)

       ,.ureg_req_rdy                       (ureg_req_rdy)
       ,.ureg_req_val                       (ureg_req_val)
       ,.ureg_req_addr                      (ureg_req_addr)
       ,.ureg_req_strb                      (ureg_req_strb)
       ,.ureg_req_data                      (ureg_req_data)
       ,.ureg_resp_rdy                      (ureg_resp_rdy)
       ,.ureg_resp_val                      (ureg_resp_val)
       ,.ureg_resp_data                     (ureg_resp_data)
       ,.ureg_resp_ecc                      (ureg_resp_ecc)

       ,.awready						    (prga_awready)
       ,.awvalid						    (prga_awvalid)
       ,.awid						        (prga_awid)
       ,.awaddr						        (prga_awaddr)
       ,.awlen						        (prga_awlen)
       ,.awsize						        (prga_awsize)
       ,.awburst						    (prga_awburst)
       ,.awcache						    (prga_awcache)
       ,.awuser						        (prga_awuser)
       ,.wready						        (prga_wready)
       ,.wvalid						        (prga_wvalid)
       ,.wdata						        (prga_wdata)
       ,.wstrb						        (prga_wstrb)
       ,.wlast						        (prga_wlast)
       ,.wuser						        (prga_wuser)
       ,.bready						        (prga_bready)
       ,.bvalid						        (prga_bvalid)
       ,.bresp						        (prga_bresp)
       ,.bid						        (prga_bid)
       ,.arready						    (prga_arready)
       ,.arvalid						    (prga_arvalid)
       ,.arid						        (prga_arid)
       ,.araddr						        (prga_araddr)
       ,.arlen						        (prga_arlen)
       ,.arsize						        (prga_arsize)
       ,.arburst						    (prga_arburst)
       ,.arlock						        (prga_arlock)
       ,.arcache						    (prga_arcache)
       ,.aruser						        (prga_aruser)
       ,.rready						        (prga_rready)
       ,.rvalid						        (prga_rvalid)
       ,.rresp						        (prga_rresp)
       ,.rid						        (prga_rid)
       ,.rdata						        (prga_rdata)
       ,.rlast						        (prga_rlast)

       );

`endif /* PITON_PRGA_MOCK_APP */
`endif /* PITON_PRGA */

endmodule

`endif
